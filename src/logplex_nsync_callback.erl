%%%-------------------------------------------------------------------
%%% @author José Manuel Rodríguez Blanco <jose@mabase>
%%% @doc
%%% Basic callback module for nsync integration into logplex
%%% @end
%%%-------------------------------------------------------------------
-module('logplex_nsync_callback').

-include_lib("logplex.hrl").
-include_lib("nsync_helper.hrl").

-export([callback/2, sync/0]).


%%--------------------------------------------------------------------
%% @doc Startup function. Creates needed ETSs for load/creation/delete
%% and modification operations. It will start the refresh_dns channel
%% operation as well as a periodic operation.
%% @spec sync() -> ok
%% @end
%%--------------------------------------------------------------------
sync() ->
    
    ets:new(logplex_token, 
	    [public, named_table, set, {keypos, #token.id}]),
    ets:new(logplex_channel, 
	    [public, named_table, set, {keypos, #channel.id}]),    
    ets:new(logplex_drain, 
	    [public, named_table, set, {keypos, #drain.id}]), 
    ets:new(logplex_channel_tokens, 
	    [public, named_table, bag, {keypos, #token.channel_id}]),    	
    ets:new(logplex_channel_drains, 
	    [public, named_table, bag, {keypos, #drain.channel_id}]),
    ets:new(logplex_session, 
	    [public, named_table, set]),
    timer:apply_interval(60*1000, logplex_channel, refresh_dns, []),
    
    Opts = [
        {block, false},
        {callback, {?MODULE, callback, [?RAW_TID]}}
    ],
    {ok, _Pid} = nsync:start_link(Opts),
    ok.

%%--------------------------------------------------------------------
%% @doc Attends nsync commands generated by redis activity. The 
%% attended commands are:
%%    - load: In case of loading a session it will stablish it to its
%%      ETS and create a timer for expiring it. Once completed the 
%%      whole raw data loading it will extract the corresponding
%%      tokens, drains and channels.
%%    - hmset: Will analyze the key in order to find if a token, drain
%%      or channel is being added to redis and add it to its
%%      corresponding ETS.
%%    - hset: Modifies an addon value for a channel and its associated
%%      tokens.
%%    - del: Deletes a token, drain or channel (and its associated
%%      data)
%%    - setex: Adds a session (no other values are taken into account)
%%      and its corresponding timeout.
%%    - publish: This command is currently ignored.
%% @spec
%% @end
%%--------------------------------------------------------------------
callback(Raw, {load, <<"/sessions", _/binary>>=Key, Val}) ->
    TTL = redis_pool:q(config_pool, [<<"TTL">>, Key]),
    logplex_session:insert_session(Key, TTL*1000, Val),
    Raw;

callback(Raw, {load, _Key, _Val}) ->
    Raw;

callback(Raw, {load, eof}) ->
    %% Trick to force raw_data to exist in the nsync_tids table
    nsync_utils:lookup_write_tid(nsync_tids, Raw),
    cross_information(ets:tab2list(nsync:tid(Raw)));

callback(Raw, {cmd, "hmset", Args}) ->
    Key = hd(Args),
    ChSize = size(Key)-length(?CHANNEL_PREFIX)-length(?DATA_SUFFIX),
    TokSize = size(Key)-length(?TOKEN_PREFIX)-length(?DATA_SUFFIX),
    DrSize = size(Key)-length(?DRAIN_PREFIX)-length(?DATA_SUFFIX),
    case Key of
	<<?CHANNEL_PREFIX, ID:ChSize/binary, ?DATA_SUFFIX>>  ->
	    logplex_channel:add_channel(ID, tl(Args));
	<<?TOKEN_PREFIX, ID:TokSize/binary, ?DATA_SUFFIX>> ->
	    logplex_token:add_token(ID, tl(Args));
	<<?DRAIN_PREFIX, ID:DrSize/binary, ?DATA_SUFFIX>> ->
	    logplex_drain:add_drain(ID, Args);
	_ ->
	    ok
    end,
    Raw;

callback(Raw, {cmd, "hset", Args}) ->
    Key = hd(Args),
    ChSize = size(Key)-length(?CHANNEL_PREFIX)-length(?DATA_SUFFIX),
    case Key of
	<<?CHANNEL_PREFIX, ID:ChSize/binary, ?DATA_SUFFIX>>  ->
	    logplex_channel:update_channel(ID, tl(Args));
	_ ->
	    ok
    end,
    Raw;

callback(Raw, {cmd, "publish", _Args}) ->
    Raw;

callback(Raw, {cmd, "del", Args}) ->
    Key = hd(Args),
    ChSize = size(Key)-length(?CHANNEL_PREFIX)-length(?DATA_SUFFIX),
    TokSize = size(Key)-length(?TOKEN_PREFIX)-length(?DATA_SUFFIX),
    DrSize = size(Key)-length(?DRAIN_PREFIX)-length(?DATA_SUFFIX),
    case Key of
	<<?CHANNEL_PREFIX, ID:ChSize/binary, ?DATA_SUFFIX>>  ->
	    logplex_channel:del_channel(ID);
	<<?TOKEN_PREFIX, ID:TokSize/binary, ?DATA_SUFFIX>> ->
	    logplex_token:del_token(ID);
	<<?DRAIN_PREFIX, ID:DrSize/binary, ?DATA_SUFFIX>> ->
	    logplex_drain:del_drain(ID);
	_ ->
	    ok
    end,
    Raw;

callback(Raw, {cmd, "setex", [Key, TTL, Value]}) ->
    case Key of
	<<"/sessions/", _/binary>> ->
	    logplex_session:insert_session(
	      Key, 
	      nsync_helper:binary_to_integer(TTL)*1000, 
	      Value);
	_ ->
	    ok
    end,
    Raw;

callback(Raw, {cmd, Cmd, Args}) ->
    io:format("Non attended command ~p with Args ~p~n", [Cmd, Args]),
    Raw;

callback(_Raw, Any) ->
    io:format("Undefined callback ~p~n",[Any]),
    ok.
   
%%--------------------------------------------------------------------
%% @private
%% @doc Crosses information from a raw list of nsync data
%% @spec cross_information(list()) -> ok
%% @end
%%--------------------------------------------------------------------
cross_information(RawList) ->
    logplex_channel:extract_channels(RawList),
    logplex_token:extract_tokens(RawList),
    logplex_drain:extract_drains(RawList),
    ok.

